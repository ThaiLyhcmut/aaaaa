# Query Chain - Simple Pipeline DSL

## Tổng quan

Query Chain là một DSL đơn giản để xây dựng chuỗi query tuần tự, tương tự như:
- **MongoDB Aggregation Pipeline**
- **PostgreSQL CTE (Common Table Expressions)**

Mỗi step trong chain nhận **output từ step trước** làm input, tạo thành một pipeline xử lý dữ liệu.

---

## Cấu trúc cơ bản

```typescript
interface QueryChain {
  _id: string;
  title: string;
  service: "QueryChain";
  entity: string;              // Entity/Collection chính để bắt đầu
  chain: ChainStep[];          // Các bước xử lý tuần tự
  result?: ResultMapping;      // Map output cuối cùng
  method: HttpMethod;
  module_name: string;
  slug: string;
  tenant_id: string;
}
```

---

## Chain Steps

### 1. Match/Filter - Lọc dữ liệu

```javascript
{
  type: "match",
  filter: {
    active: true,
    status: "completed"
  }
}
```

**MongoDB:**
```javascript
{ $match: { active: true, status: "completed" } }
```

**PostgreSQL:**
```sql
WHERE active = TRUE AND status = 'completed'
```

---

### 2. Lookup/Join - Nối bảng

```javascript
{
  type: "lookup",
  from: "orders",                  // Entity/table to join
  localField: "_id",               // Field từ entity hiện tại
  foreignField: "user_id",         // Field từ entity đích
  as: "orders"                     // Tên field output
}
```

**MongoDB:**
```javascript
{
  $lookup: {
    from: "orders",
    localField: "_id",
    foreignField: "user_id",
    as: "orders"
  }
}
```

**PostgreSQL:**
```sql
LEFT JOIN orders ON users.id = orders.user_id
```

---

### 3. Unwind - Giải phẳng array

```javascript
{
  type: "unwind",
  path: "$orders"
}
```

**MongoDB:**
```javascript
{ $unwind: "$orders" }
```

**PostgreSQL:**
```sql
CROSS JOIN LATERAL unnest(orders) AS order_item
```

---

### 4. Project/Select - Chọn fields

```javascript
{
  type: "project",
  fields: {
    _id: 1,
    name: 1,
    email: 1,
    "orders.total": 1
  }
}
```

**MongoDB:**
```javascript
{
  $project: {
    _id: 1,
    name: 1,
    email: 1,
    "orders.total": 1
  }
}
```

**PostgreSQL:**
```sql
SELECT id, name, email, orders.total
```

---

### 5. Group/Aggregate - Gom nhóm

```javascript
{
  type: "group",
  by: ["user_id"],
  fields: {
    total: { $sum: "$amount" },
    count: { $count: "*" },
    avg: { $avg: "$score" }
  }
}
```

**MongoDB:**
```javascript
{
  $group: {
    _id: "$user_id",
    total: { $sum: "$amount" },
    count: { $sum: 1 },
    avg: { $avg: "$score" }
  }
}
```

**PostgreSQL:**
```sql
GROUP BY user_id
SELECT user_id, SUM(amount) as total, COUNT(*) as count, AVG(score) as avg
```

---

### 6. Sort - Sắp xếp

```javascript
{
  type: "sort",
  fields: {
    created_at: -1,    // -1 = DESC
    name: 1            // 1 = ASC
  }
}
```

**MongoDB:**
```javascript
{ $sort: { created_at: -1, name: 1 } }
```

**PostgreSQL:**
```sql
ORDER BY created_at DESC, name ASC
```

---

### 7. Limit/Skip - Phân trang

```javascript
{
  type: "limit",
  value: 10
}

{
  type: "skip",
  value: 20
}
```

**MongoDB:**
```javascript
{ $limit: 10 }
{ $skip: 20 }
```

**PostgreSQL:**
```sql
LIMIT 10 OFFSET 20
```

---

## Ví dụ hoàn chỉnh

### Input DSL

```javascript
{
  "_id": "6786582f6d9b09071159c439",
  "title": "Get active users with orders",
  "service": "QueryChain",
  "entity": "users",
  "chain": [
    {
      "type": "match",
      "filter": {
        "active": true
      }
    },
    {
      "type": "lookup",
      "from": "orders",
      "localField": "_id",
      "foreignField": "user_id",
      "as": "orders"
    },
    {
      "type": "unwind",
      "path": "$orders"
    },
    {
      "type": "match",
      "filter": {
        "orders.total": { "$gt": 100 }
      }
    },
    {
      "type": "project",
      "fields": {
        "_id": 1,
        "name": 1,
        "email": 1,
        "orders.total": 1,
        "orders.status": 1
      }
    },
    {
      "type": "sort",
      "fields": {
        "orders.total": -1
      }
    },
    {
      "type": "limit",
      "value": 10
    }
  ],
  "method": "get-list",
  "module_name": "user",
  "slug": "get-users-with-large-orders"
}
```

---

### Output MongoDB Aggregation

```javascript
db.users.aggregate([
  {
    $match: { active: true }
  },
  {
    $lookup: {
      from: "orders",
      localField: "_id",
      foreignField: "user_id",
      as: "orders"
    }
  },
  {
    $unwind: "$orders"
  },
  {
    $match: { "orders.total": { $gt: 100 } }
  },
  {
    $project: {
      _id: 1,
      name: 1,
      email: 1,
      "orders.total": 1,
      "orders.status": 1
    }
  },
  {
    $sort: { "orders.total": -1 }
  },
  {
    $limit: 10
  }
])
```

---

### Output PostgreSQL CTE

```sql
WITH
step_1 AS (
  SELECT * FROM users WHERE active = TRUE
),
step_2 AS (
  SELECT
    u.*,
    o.*
  FROM step_1 u
  LEFT JOIN orders o ON u.id = o.user_id
),
step_3 AS (
  SELECT * FROM step_2 WHERE total > 100
),
step_4 AS (
  SELECT
    id,
    name,
    email,
    total,
    status
  FROM step_3
)
SELECT * FROM step_4
ORDER BY total DESC
LIMIT 10;
```

---

## Data Binding

### Từ Request

```javascript
{
  "type": "match",
  "filter": {
    "user_id": "@param:user_id",           // URL param
    "status": "@body:status",              // Request body
    "tenant_id": "@header:x-tenant-id"     // Header
  }
}
```

### Từ Step trước

```javascript
{
  "type": "match",
  "filter": {
    "user_id": {
      "$in": "@step_1._id"    // Lấy _id từ step_1
    }
  }
}
```

### Context

Mỗi step tự động lưu result vào context với key = index:

```javascript
context = {
  step_1: [ /* result từ step 1 */ ],
  step_2: [ /* result từ step 2 */ ],
  step_3: [ /* result từ step 3 */ ]
}
```

---

## Ví dụ thực tế - 3 steps phức tạp

### Bài toán:
1. Lấy danh sách user active
2. Lấy orders của những users đó
3. Filter orders có total > 100

```javascript
{
  "entity": "users",
  "chain": [
    // Step 1: Get active users
    {
      "type": "match",
      "filter": { "active": true }
    },
    {
      "type": "project",
      "fields": { "_id": 1, "name": 1, "email": 1 }
    },

    // Step 2: Lookup orders
    {
      "type": "lookup",
      "from": "orders",
      "localField": "_id",
      "foreignField": "user_id",
      "as": "orders"
    },
    {
      "type": "unwind",
      "path": "$orders"
    },

    // Step 3: Filter orders
    {
      "type": "match",
      "filter": {
        "orders.total": { "$gt": 100 },
        "orders.status": "completed"
      }
    },

    // Final output
    {
      "type": "group",
      "by": ["_id", "name", "email"],
      "fields": {
        "total_spent": { "$sum": "$orders.total" },
        "order_count": { "$count": "*" }
      }
    },
    {
      "type": "sort",
      "fields": { "total_spent": -1 }
    },
    {
      "type": "limit",
      "value": 20
    }
  ]
}
```

**Result:**
```json
[
  {
    "_id": "user_1",
    "name": "John Doe",
    "email": "john@example.com",
    "total_spent": 5000,
    "order_count": 15
  },
  {
    "_id": "user_2",
    "name": "Jane Smith",
    "email": "jane@example.com",
    "total_spent": 4500,
    "order_count": 12
  }
]
```

---

## Compiler Implementation

### MongoDB Adapter

```typescript
function compileMongoChain(queryChain: QueryChain) {
  const pipeline = [];

  for (const step of queryChain.chain) {
    switch (step.type) {
      case "match":
        pipeline.push({ $match: resolveBindings(step.filter) });
        break;

      case "lookup":
        pipeline.push({
          $lookup: {
            from: step.from,
            localField: step.localField,
            foreignField: step.foreignField,
            as: step.as
          }
        });
        break;

      case "unwind":
        pipeline.push({ $unwind: step.path });
        break;

      case "project":
        pipeline.push({ $project: step.fields });
        break;

      case "group":
        pipeline.push({
          $group: {
            _id: buildGroupId(step.by),
            ...step.fields
          }
        });
        break;

      case "sort":
        pipeline.push({ $sort: step.fields });
        break;

      case "limit":
        pipeline.push({ $limit: step.value });
        break;

      case "skip":
        pipeline.push({ $skip: step.value });
        break;
    }
  }

  return {
    collection: queryChain.entity,
    pipeline
  };
}
```

### PostgreSQL Adapter

```typescript
function compilePostgresChain(queryChain: QueryChain) {
  const ctes = [];
  let currentTable = queryChain.entity;
  let stepIndex = 0;

  for (const step of queryChain.chain) {
    stepIndex++;
    const stepName = `step_${stepIndex}`;

    switch (step.type) {
      case "match":
        const where = buildWhereClause(step.filter);
        ctes.push(`${stepName} AS (
          SELECT * FROM ${currentTable}
          WHERE ${where}
        )`);
        currentTable = stepName;
        break;

      case "lookup":
        ctes.push(`${stepName} AS (
          SELECT t.*, j.*
          FROM ${currentTable} t
          LEFT JOIN ${step.from} j
            ON t.${step.localField} = j.${step.foreignField}
        )`);
        currentTable = stepName;
        break;

      case "project":
        const fields = Object.keys(step.fields).join(", ");
        ctes.push(`${stepName} AS (
          SELECT ${fields}
          FROM ${currentTable}
        )`);
        currentTable = stepName;
        break;

      // ... other cases
    }
  }

  return `WITH ${ctes.join(",\n")} SELECT * FROM ${currentTable};`;
}
```

---

## Kết luận

**Query Chain** là cách đơn giản nhất để:

✅ Viết logic query phức tạp bằng JSON
✅ Compile sang MongoDB Aggregation hoặc PostgreSQL CTE
✅ **1 query duy nhất** xuống DB (không có round-trip)
✅ Dễ hiểu, dễ maintain
✅ Support data binding từ request/context
✅ Portable giữa nhiều DB

**So sánh:**
- **Query Chain**: Đơn giản, tuần tự, phù hợp 90% use case
- **DataFlow (Nodes/Edges)**: Phức tạp, có branching/parallel, phù hợp workflow engine

→ **Đề xuất: Dùng Query Chain cho MongoREST response handler!**
